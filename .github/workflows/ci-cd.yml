name: CI/CD Pipeline with VPS Deployment

on:
  pull_request:
    branches: [ main ]
  push:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_PASSWORD: password
          POSTGRES_DB: interview_ai_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Build and test orchestrator
      run: |
        docker build -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/orchestrator:test ./orchestrator
        docker run --rm \
          -e DATABASE_URL="postgresql://postgres:password@host.docker.internal:5432/interview_ai_test" \
          -e AZURE_OPENAI_API_KEY="${{ secrets.AZURE_OPENAI_API_KEY }}" \
          -e AZURE_OPENAI_ENDPOINT="${{ secrets.AZURE_OPENAI_ENDPOINT }}" \
          -e MINIO_ENDPOINT="minio:9000" \
          -e MINIO_ACCESS_KEY="minioadmin" \
          -e MINIO_SECRET_KEY="minioadmin123" \
          -e MINIO_BUCKET_NAME="audio-files" \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/orchestrator:test \
          python -c "import app; print('Orchestrator imports successfully')"

    - name: Build and test STT
      run: |
        docker build -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/stt:test ./stt
        docker run --rm \
          -e MINIO_ENDPOINT="minio:9000" \
          -e MINIO_ACCESS_KEY="minioadmin" \
          -e MINIO_SECRET_KEY="minioadmin123" \
          -e MINIO_BUCKET_NAME="audio-files" \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/stt:test \
          python -c "import app; print('STT imports successfully')"

    - name: Build and test LLM
      run: |
        docker build -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/llm:test ./llm
        docker run --rm \
          -e AZURE_OPENAI_API_KEY="${{ secrets.AZURE_OPENAI_API_KEY }}" \
          -e AZURE_OPENAI_ENDPOINT="${{ secrets.AZURE_OPENAI_ENDPOINT }}" \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/llm:test \
          python -c "import app; print('LLM imports successfully')"

    - name: Build and test Avatar
      run: |
        docker build -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/avatar:test ./avatar
        docker run --rm \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/avatar:test \
          python -c "import app; print('Avatar imports successfully')"

    - name: Build and test Scoring
      run: |
        docker build -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/scoring:test ./scoring
        docker run --rm \
          -e AZURE_OPENAI_API_KEY="${{ secrets.AZURE_OPENAI_API_KEY }}" \
          -e AZURE_OPENAI_ENDPOINT="${{ secrets.AZURE_OPENAI_ENDPOINT }}" \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/scoring:test \
          python -c "import app; print('Scoring imports successfully')"

    - name: Build frontend
      run: |
        docker build -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/frontend:test ./frontend
        docker run --rm \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/frontend:test \
          nginx -t

  build:
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.pull_request.merged == true
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: |
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/orchestrator
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/stt
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/llm
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/avatar
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/scoring
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/frontend
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha

    - name: Build and push orchestrator
      uses: docker/build-push-action@v5
      with:
        context: ./orchestrator
        push: true
        tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/orchestrator:${{ steps.meta.outputs.version }}
        labels: ${{ steps.meta.outputs.labels }}

    - name: Build and push STT
      uses: docker/build-push-action@v5
      with:
        context: ./stt
        push: true
        tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/stt:${{ steps.meta.outputs.version }}
        labels: ${{ steps.meta.outputs.labels }}

    - name: Build and push LLM
      uses: docker/build-push-action@v5
      with:
        context: ./llm
        push: true
        tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/llm:${{ steps.meta.outputs.version }}
        labels: ${{ steps.meta.outputs.labels }}

    - name: Build and push Avatar
      uses: docker/build-push-action@v5
      with:
        context: ./avatar
        push: true
        tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/avatar:${{ steps.meta.outputs.version }}
        labels: ${{ steps.meta.outputs.labels }}

    - name: Build and push Scoring
      uses: docker/build-push-action@v5
      with:
        context: ./scoring
        push: true
        tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/scoring:${{ steps.meta.outputs.version }}
        labels: ${{ steps.meta.outputs.labels }}

    - name: Build and push Frontend
      uses: docker/build-push-action@v5
      with:
        context: ./frontend
        push: true
        tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/frontend:${{ steps.meta.outputs.version }}
        labels: ${{ steps.meta.outputs.labels }}

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.pull_request.merged == true
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.8.0
      with:
        ssh-private-key: ${{ secrets.SERVER_SSH_KEY }}

    - name: Deploy to VPS
      run: |
        echo "Deploying to VPS server..."
        
        # Создаем директорию на сервере
        ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "mkdir -p /opt/interview-ai"
        
        # Копируем файлы на сервер
        scp -o StrictHostKeyChecking=no docker-compose.prod.yml ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/opt/interview-ai/
        scp -o StrictHostKeyChecking=no env.prod.sample ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/opt/interview-ai/.env.prod
        
        # Деплоим на сервер
        ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
          cd /opt/interview-ai
          
          # Обновляем теги образов
          sed -i "s|image: .*/orchestrator:.*|image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/orchestrator:${{ steps.meta.outputs.version }}|g" docker-compose.prod.yml
          sed -i "s|image: .*/stt:.*|image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/stt:${{ steps.meta.outputs.version }}|g" docker-compose.prod.yml
          sed -i "s|image: .*/llm:.*|image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/llm:${{ steps.meta.outputs.version }}|g" docker-compose.prod.yml
          sed -i "s|image: .*/avatar:.*|image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/avatar:${{ steps.meta.outputs.version }}|g" docker-compose.prod.yml
          sed -i "s|image: .*/scoring:.*|image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/scoring:${{ steps.meta.outputs.version }}|g" docker-compose.prod.yml
          sed -i "s|image: .*/frontend:.*|image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/frontend:${{ steps.meta.outputs.version }}|g" docker-compose.prod.yml
          
          # Обновляем образы
          docker compose -f docker-compose.prod.yml pull
          
          # Перезапускаем сервисы
          docker compose -f docker-compose.prod.yml down
          docker compose -f docker-compose.prod.yml up -d
          
          # Проверяем статус
          docker compose -f docker-compose.prod.yml ps
        EOF
        
    - name: Notify deployment
      run: |
        echo "Deployment completed successfully!"
        echo "Application URL: http://${{ secrets.SERVER_HOST }}:3000"
        echo "New images tagged with: ${{ needs.build.outputs.version }}"
